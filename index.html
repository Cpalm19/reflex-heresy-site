<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>REFLEX HERESY // GLOBAL ACCESS TERMINAL</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      background: #000;
      color: #00ffc8;
      font-family: "Consolas", "Fira Code", monospace;
      font-size: 16px;
      margin: 0;
      padding: 20px;
      overflow: hidden;
    }
    #wrapper {
      max-width: 900px;
      margin: 0 auto;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #terminal {
      flex: 1;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .line {
      margin: 0;
    }
    .system {
      color: #00ffc8;
    }
    .warning {
      color: #ff4b4b;
    }
    .muted {
      color: #666;
    }
    #input-row {
      border-top: 1px solid #00ffc83a;
      padding-top: 8px;
      margin-top: 8px;
    }
    #prompt {
      display: inline-block;
      margin-right: 6px;
      color: #00ffc8;
    }
    #command {
      display: inline-block;
      min-width: 10px;
      word-break: break-all;
    }
    .cursor {
      display: inline-block;
      width: 10px;
      margin-left: 2px;
      background: #00ffc8;
      animation: blink 0.7s step-end infinite;
    }
    @keyframes blink {
      0% { opacity: 0; }
      50% { opacity: 1; }
      100% { opacity: 0; }
    }
    ::selection {
      background: #00ffc83a;
    }
  </style>
</head>
<body>
  <div id="wrapper">
    <div id="terminal"></div>
    <div id="input-row">
      <span id="prompt">&gt;</span>
      <span id="command"></span><span class="cursor"></span>
    </div>
  </div>

  <script>
    const terminal = document.getElementById("terminal");
    const commandEl = document.getElementById("command");
    let buffer = "";
    let bootComplete = false;
    let commandHistory = [];
    let historyIndex = -1;

    const BOOT_LINES = [
      "> REFLEX HERESY // AUTONOMOUS REFLEX SYSTEM",
      "> GLOBAL ACCESS TERMINAL v0.9.2",
      "> -------------------------------------------------",
      "> Initializing telemetry bus............ OK",
      "> Synchronizing reflex modules.......... OK",
      "> Verifying safety interlocks........... LOCKED",
      "> External control surface.............. DISABLED",
      "> User routing mode..................... OBSERVER",
      "> -------------------------------------------------",
      "> NOTICE: This interface provides LIMITED, READ-ONLY interaction",
      "> with the Reflex System diagnostics shell.",
      "> Authorization to modify control surfaces is RESTRICTED.",
      "",
      "> Type 'HELP' for available commands."
    ];

    function printLine(text = "", cssClass = "system") {
      const line = document.createElement("div");
      line.className = "line " + cssClass;
      line.textContent = text;
      terminal.appendChild(line);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function printBlock(lines, cssClass = "system") {
      lines.forEach(l => printLine(l, cssClass));
    }

    function handleCommand(raw) {
      const cmd = raw.trim();
      if (!cmd) return;

      commandHistory.unshift(cmd);
      historyIndex = -1;

      printLine("> " + cmd, "system");

      const upper = cmd.toUpperCase();

      switch (true) {
        case upper === "HELP":
          printBlock([
            "AVAILABLE COMMANDS:",
            "  HELP         - List available commands",
            "  STATUS       - High-level system status",
            "  DIAGNOSTICS  - Basic health summary",
            "  ACCESS       - Query access level and restrictions",
            "  MODULES      - List major system domains",
            "  REFLEX       - Describe reflex control system",
            "  CLEAR        - Clear terminal output"
          ]);
          break;

        case upper === "STATUS":
          printBlock([
            "REFLEX SYSTEM STATUS:",
            "  Engine Core:           STANDBY",
            "  Reflex Control:        ARMED (SIMULATION ONLY)",
            "  External Interfaces:   ISOLATED",
            "  Safety Interlocks:     ENGAGED",
            "  User Level:            OBSERVER / READ-ONLY",
            "  Modification Rights:   RESTRICTED"
          ]);
          break;

        case upper === "DIAGNOSTICS":
          printBlock([
            "RUNNING NON-INVASIVE DIAGNOSTICS...",
            "  Telemetry Link:        STABLE",
            "  Command Latency:       < 4 ms (simulated)",
            "  Lane/Vector Channel:   IDLE",
            "  Traction Model:        READY",
            "  Hardware Bridge:       OFFLINE (NO VEHICLE ATTACHED)",
            "",
            "NOTE: This terminal is operating in DEMO / OBSERVER MODE.",
            "      No live hardware is currently under Reflex control."
          ]);
          break;

        case upper === "ACCESS":
        case upper.startsWith("ACCESS "):
          printBlock([
            "ACCESS CONTROL:",
            "  You are connected to a GLOBAL OBSERVER TERMINAL.",
            "  Privilege Tier:        LEVEL 0 (CIVILIAN / READ-ONLY)",
            "  Write Access:          DISABLED",
            "  Override Channel:      SEALED",
            "",
            "REQUESTED ESCALATION:    DENIED",
            "REASON:                  Production Reflex instances are not",
            "                         addressable from this interface."
          ], "warning");
          break;

        case upper === "MODULES":
          printBlock([
            "PRIMARY MODULES (ABSTRACTED):",
            "  REFLEX_CORE        - Central reflex loop orchestration",
            "  TRACTION_AI        - Surface + grip modeling (sim-only here)",
            "  LANE_VECTOR        - Directional alignment + correction",
            "  TREE_VISION        - Timing and start-signal analysis",
            "  TELEMETRY_BUS      - Run data capture / export",
            "",
            "NOTE: This terminal is a synthetic shell. Direct module binding",
            "      to hardware is disabled in this environment."
          ]);
          break;

        case upper === "REFLEX":
        case upper === "REFLEX ENGINE":
          printBlock([
            "REFLEX ENGINE OVERVIEW:",
            "  Design Objective:",
            "    Reduce effective reaction time below human latency by",
            "    precomputing likely control actions and staging them",
            "    in a constrained, safety-checked pipeline.",
            "",
            "  Current Mode:         DEMO / ISOLATED",
            "  Live Output:          NOT ROUTED",
            "",
            "This terminal exposes description and simulated telemetry only.",
            "No real-world actuators are connected to this shell."
          ]);
          break;

        case upper === "CLEAR":
        case upper === "CLS":
          terminal.innerHTML = "";
          break;

        default:
          printBlock([
            "UNRECOGNIZED OR UNAVAILABLE COMMAND.",
            "Type 'HELP' for a list of supported diagnostic queries.",
            "",
            "NOTE: This terminal cannot grant control authority. All",
            "      modification and override paths are sealed from this node."
          ], "warning");
          break;
      }
    }

    function handleKey(e) {
      if (!bootComplete) return;

      if (e.key === "Backspace") {
        e.preventDefault();
        buffer = buffer.slice(0, -1);
        commandEl.textContent = buffer;
        return;
      }

      if (e.key === "Enter") {
        e.preventDefault();
        const cmd = buffer;
        buffer = "";
        commandEl.textContent = "";
        handleCommand(cmd);
        return;
      }

      if (e.key === "ArrowUp") {
        e.preventDefault();
        if (commandHistory.length > 0) {
          historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
          buffer = commandHistory[historyIndex];
          commandEl.textContent = buffer;
        }
        return;
      }

      if (e.key === "ArrowDown") {
        e.preventDefault();
        if (historyIndex <= 0) {
          historyIndex = -1;
          buffer = "";
        } else {
          historyIndex -= 1;
          buffer = commandHistory[historyIndex];
        }
        commandEl.textContent = buffer;
        return;
      }

      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
        buffer += e.key;
        commandEl.textContent = buffer;
      }
    }

    function runBootSequence(lines, idx = 0) {
      if (idx >= lines.length) {
        bootComplete = true;
        return;
      }
      printLine(lines[idx]);
      setTimeout(() => runBootSequence(lines, idx + 1), 80);
    }

    window.addEventListener("keydown", handleKey);
    runBootSequence(BOOT_LINES);
  </script>
</body>
</html>
